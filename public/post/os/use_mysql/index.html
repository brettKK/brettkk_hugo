<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <title>mysql 小结 | brettkk</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="raft基本思想：少数服从多数。 leader 选举 &#43; 发起投票 &#43; 每个节点为">
<meta name="generator" content="Hugo 0.72.0" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">
<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/googlecode.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/highlight.js/10.0.1/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>







  </head>
  
  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	

	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">mysql 小结</h1>

    <div class="tip">
        <span>
          May 5, 2021 11:33
        </span>
        <span class="split">
          ·
        </span>
        <span>
          
            2167 words
          
        </span>
        <span class="split">
          ·
        </span>
        <span>
          5 minute read
        </span>
    </div>

    <div class="content" >
      <article class="content">
        <p>存储引擎-是创建表时设置的，所以存储引擎是表级别的使用</p>

<ul>
<li>innodb: 只有数据文件即时索引文件，一个表对应一个文件

<ul>
<li>各类索引</li>
<li>聚集索引</li>
<li>辅助索引</li>
<li>联合索引</li>
<li>覆盖索引</li>
<li>全文索引</li>
</ul></li>
<li>mysiam: 既有数据文件，又有索引文件

<ul>
<li>全文索引</li>
</ul></li>
</ul>

<hr>

<ul>
<li>SQL

<ul>
<li>DML

<ul>
<li>select  join ，左连接，右连接值做联合查询时结果以哪边为准； inner join ，left join，right join</li>
<li>insert

<ul>
<li>insert into tb_name(a,b,c) values(1,2,3)</li>
<li>insert into tb_name(a,b,c) values(1,2,3),(4,5,6),(7,8,9);</li>
<li>insert into tb_name(a,b,c) select a,b,c from tb_name1;</li>
<li>unique constraint</li>
</ul></li>
<li>update

<ul>
<li>update tb_name set b = b+1 where name='aaa'</li>
</ul></li>
<li>delete</li>
</ul></li>
<li>DDL (implicit commit and cannot be roll back)

<ul>
<li>create</li>
<li>drop, 删除表</li>
<li>truncate，清空表</li>
<li>rename, only table name</li>
<li>alter

<ul>
<li>alter table tt add column city varchar(50)</li>
<li>add, modify/change, drop</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>delete, drop, truncate区别</p>

<ul>
<li>drop,truncate属于DDL， 不能回滚</li>
<li>drop删除表结构，delete用于删除某些行，truncate用于清空所有行</li>
</ul>

<hr>

<ul>
<li>字段类型

<ul>
<li>数字 （int(tinyint, smallint,...bigint), decimal(金钱), float, double）</li>
<li>字符类 (char,varchar,text,blob)

<ul>
<li>varchar(50)表示最大存放50个字符, char</li>
<li>int(10)表示最大显示宽度为10,存储还是占4字节</li>
</ul></li>
<li>时间日期类

<ul>
<li>date, '1000-01-01' to '9999-12-31'</li>
<li>datetime, '1000-01-01 00:00:00' t0 '9999-12-31 00:00:00',范围广</li>
<li>timestamp, '1970-01-01 00:00:01' UTC to '2038-01-19 03:14:07' UTC</li>
</ul></li>
</ul></li>
</ul>

<hr>

<ul>
<li>Master-Slave 原理 （Binlog, Relay log）

<ul>
<li>异步复制

<ul>
<li>主库

<ul>
<li>当从库连接式，binlog dump thread发送binlog event,并持有event的lock</li>
<li>IO thread 读完后释放lock<br></li>
</ul></li>
<li>从库

<ul>
<li>IO thread读binlog event，生成relay log</li>
<li>SQL thread 读relay log，执行</li>
</ul></li>
</ul></li>
<li>Binlog, Relay log

<ul>
<li>SQL(增删改查，DDL)语句按 提交顺序 生成的日志，用于数据回滚，异步复制</li>
<li>Relay log通过异步复制Master中的binlog，生成slave的执行日志</li>
<li>Binlog的3种存储格式：binlog_format(row, statement, mixed)

<ul>
<li>statement格式： 每一条会修改数据的sql都会记录在binlog中</li>
<li>row： 不记录sql语句上下文相关信息，仅保存哪条记录被修改</li>
<li>mixed： 混合 （Binlog记录数据库发生的变化,用于replication）</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<hr>

<h4 id="sql优化">sql优化</h4>

<ul>
<li>搜索字段上建索引，不在索引字段上使用函数</li>
<li>避免select * ,  这样杜绝去使用覆盖索引

<ul>
<li>在innodb引擎下，select a,b,c 可以走辅助索引找到所有的数据，避免走到聚集索引上，减少一次聚集索引查询过程</li>
<li>减少数据传输量，limit 好习惯</li>
</ul></li>
<li>不使用like ‘%xx’, 多用区间操作, 能用 between 就不要用 in<br></li>
<li>复合索引最左前缀 (不是指SQL语句的where顺序要和复合索引一致)

<ul>
<li>复合索引底层存储也是一颗B+树，只不过排序key=（a,b,c）, 这样是复合索引使用时需要满足最左前缀的原理</li>
</ul></li>
<li>避免大事务（避免夹杂rpc）</li>
<li>避免使用子查询， 子查询产生的临时表再扫描无索引可走，会全表扫描</li>
<li>explain 显示select语句的执行计划

<ul>
<li>select_type: simple等</li>
<li>type： 判断查询是否高效，const, ref, range, index,all</li>
<li>extra： using index, using filesort(不能通过索引达到排序), using temporary(使用了临时表)</li>
</ul></li>
</ul>

<hr>

<ul>
<li>mysql transaction （ACID 锁保证隔离性， relog 保证原子性和持久性， undo保证一致性）

<ul>
<li>隔离级别 可在终端进行模拟

<ul>
<li>read uncommited （tranx will read dity data）

<ul>
<li>读脏数据</li>
</ul></li>
<li>read committed (no repeatable read)

<ul>
<li>不可重复读（事务中两次读的结果不一致）</li>
<li>事务1等读到事务2的commit， 从数据库对事务ACID角度上讲，违背了隔离性</li>
</ul></li>
<li>repeatable read (default mode)

<ul>
<li>事务在运行时看到相同的数据，可重复读</li>
<li>存在幻读（innodb的间隙锁解决）</li>
</ul></li>
<li>seriablizable</li>
</ul></li>
<li>mvcc

<ul>
<li>增加2列，一列保存行的创建时间，一列保存行的删除时间</li>
<li>undo log 实现了读写不冲突，可重复读，提高了性能<br></li>
</ul></li>
</ul></li>
<li>innodb重要的日志，undo logs, redo logs

<ul>
<li>undo logs: 记录某数据被修改前的值，可以用来在事务失败时进行rollback，保证一致性

<ul>
<li>逻辑日志，随机写，每行记录修改， 采用段的方式</li>
<li>帮助事务回滚以及MVCC功能</li>
</ul></li>
<li>redo logs: 保证事务的原子性和持久性

<ul>
<li>物理日志，顺序写，512字节，记录的是页的物理修改操作</li>
<li>确保redo log写入磁盘，事务提交前需要fsync操作。 因此磁盘的性能决定了事务提交的性能。</li>
</ul></li>
</ul></li>
<li>undo+redo log

<ul>
<li>为保证事务的持久性，事务提交前先写redo log持久化（WAL）</li>
<li>数据不需要在事务提交前写入磁盘，而是在内存的缓存中</li>
<li>redo log保证事务的持久性， undo log保证事务的原子性</li>
</ul></li>
</ul>

<hr>

<ul>
<li>mysql 锁

<ul>
<li>mysql锁类型，锁机制 （InnoDB 检索数据走索引是行锁，不走索引，是表锁）

<ul>
<li>行级锁

<ul>
<li>Record Lockx 对索引项加锁，锁定一条记录</li>
<li>Gap Lockx 锁定一个范围，不包含记录本身</li>
<li>Next-Key Lock = gap + record lock, 锁定一个范围 并锁定记录本身

<ul>
<li>查询的索引包含唯一属性时，next-key lock 降级为record lock</li>
</ul></li>
</ul></li>
<li>表级锁 （不会出现死锁）MyISAM 读写，写写都是串行的 另 页面锁</li>
</ul></li>
</ul></li>
</ul>

<hr>

<ul>
<li><p>死锁的必要条件</p>

<ul>
<li>互斥</li>
<li>请求并保留</li>
<li>不剥夺</li>
<li>循环等待</li>
</ul></li>

<li><p>InnoDB 检测死锁 2种情况</p>

<ul>
<li>2行记录交叉申请互斥锁</li>
<li>同一张表存在主键索引锁冲突</li>
</ul></li>

<li><p>死锁的注意事项：</p>

<ul>
<li>InnoDB的行锁是加在索引上的</li>
<li>InnoDB的索引的修改会锁定更多的行</li>
<li>InnoDB加锁是边查询边加锁，逐行获得锁</li>
<li>InnoDB表的并发过多，会达到锁的最大深度，或者锁的最大</li>
<li>锁的升级也会导致死锁，建议事务开始就获得所有资源</li>
</ul></li>
</ul>

<hr>

<ul>
<li>InnoDB表中数据按行存储 类似网络协议栈，由页头，区头，段头，表头</li>
<li>一个页面大小为16k，包含多行</li>
<li>一个区由64个页组成，为1M</li>

<li><p>一个段由多个区组成，构成表空间文件ibd （数据段、索引段、回滚段）</p></li>

<li><p>mysql innodb存储引擎的文件结构</p>

<ul>
<li>共享表空间文件（ibdata1）</li>
<li>独占表空间文件（ibd）</li>
<li>表结构文件（user.frm， 表名 + .frm组成整个名称），与具体存储引擎无关</li>
<li>日志文件（redo文件等）</li>
</ul></li>
</ul>

<p>数据库使用自增主键作为唯一key时可能的问题： 分库分表时，会出现主键重复。</p>

      </article>
    </div>

    <div class="article-nav" id="article-nav-id">
        <nav class="hide-on-mobile section-nav">
          <h3 class="ml-1">Table of contents</h3>
            
        </nav>
    </div>

    
        <div class="tags">
            
                <a href="http://brettkk.github.io/tags/linux">linux</a>
            
        </div>
    

    <div class="post-comment">
      
             
      
      
      


<div class="post bg-white">
    <script src="https://utteranc.es/client.js"
          repo="brettkk/brettkk.github.io"
          issue-term="pathname"
          theme="github-light"
          crossorigin="anonymous"
          async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>
</div>
    </div>
    

</section>

<script>
	window.addEventListener('DOMContentLoaded', () => {
		const observerForTableOfContentActiveState = new IntersectionObserver(entries => {
			entries.forEach(entry => {
				const id = entry.target.getAttribute('id');

				if (entry.intersectionRatio > 0) {					
					clearActiveStatesInTableOfContents();				
					document.querySelector(`nav li a[href="#${id}"]`).parentElement.classList.add('active');
				}
			});
		});		
		document.querySelectorAll('h1[id],h2[id],h3[id],h4[id]').forEach((section) => {
			observerForTableOfContentActiveState.observe(section);
		});

	});

	function clearActiveStatesInTableOfContents() {
		document.querySelectorAll('nav li').forEach((section) => {
			section.classList.remove('active');
		});
	}
</script>


    </main>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<footer id="footer">
    

    <p class="copyright">
    
       © Copyright 
       2021 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       
    
    </p>
    <p class="powerby">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

  </body>
</html>
