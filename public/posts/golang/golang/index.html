<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <title>golang | brettkk</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="">
<meta name="generator" content="Hugo 0.84.0" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link href="https://cdn.bootcss.com/highlight.js/9.15.10/styles/zenburn.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<link rel="stylesheet" href="http://brettkk.github.io/css/syntax.css" />


<link rel="stylesheet" href="/css/style.css">
<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />








  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	

	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">golang</h1>

    <div class="tip">
        <span>
          May 7, 2021 18:54
        </span>
        <span class="split">
          ·
        </span>
        <span>
          
            2136 words
          
        </span>
        <span class="split">
          ·
        </span>
        <span>
          5 minute read
        </span>
    </div>

    <div class="content">
      <h2 id="资料">资料 <a href="#%e8%b5%84%e6%96%99" class="anchor">🔗</a></h2><ol>
<li>
<p>目前golang的主要maintainer: Russ Cox</p>
</li>
<li>
<p>个人主页：swtch.com/~rsc/</p>
</li>
<li>
<p>awesome-go系列，https://github.com/gocn/knowledge</p>
</li>
</ol>
<hr>
<h2 id="多态继承-范型">多态，继承， 范型 <a href="#%e5%a4%9a%e6%80%81%e7%bb%a7%e6%89%bf-%e8%8c%83%e5%9e%8b" class="anchor">🔗</a></h2><p>golang中面向对象的实现方式</p>
<h3 id="继承">继承 <a href="#%e7%bb%a7%e6%89%bf" class="anchor">🔗</a></h3><p>组合结构体，一个结构体嵌入另一个结构体，能够实现对嵌入结构体的字段以及其实现的方法的继承， 。</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">type</span> <span class="nx">person</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">name</span> <span class="kt">string</span>
    <span class="nx">age</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">student</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">person</span> <span class="c1">//   匿名字段，通过组合的方式
</span><span class="c1"></span>    <span class="nx">school</span> <span class="kt">string</span> 
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span> <span class="nx">person</span><span class="p">)</span> <span class="nf">talk</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">age</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">student</span><span class="p">)</span> <span class="nf">getSchool</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">school</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="nx">student</span><span class="p">{</span><span class="nx">person</span><span class="p">{</span><span class="s">&#34;brettkk&#34;</span><span class="p">,</span> <span class="mi">18</span><span class="p">},</span> <span class="s">&#34;yidu&#34;</span><span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="c1">// 继承person的name字段
</span><span class="c1"></span>    <span class="nx">s</span><span class="p">.</span><span class="nf">talk</span><span class="p">()</span> <span class="c1">// 继承person实现的方法
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><h3 id="多态">多态 <a href="#%e5%a4%9a%e6%80%81" class="anchor">🔗</a></h3><p>go没有 implements, extends 关键字， golang是去鸭子类型：看起来像鸭子， 那么它就是鸭子。</p>
<p>多态： 父类指针或引用去调用方法，在执行的时候，能够根据子类的类型去执行子类当中的方法。</p>
<p>为什么是在执行的时候才能根据子类的类型执行子类的方法？</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang">
<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">gender</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Men</span> <span class="kd">struct</span><span class="p">{</span>
    <span class="nx">Gender</span> <span class="kt">string</span>
    <span class="nx">Age</span> <span class="kt">int</span>
    <span class="nx">Name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Woman</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Gender</span> <span class="kt">string</span>
    <span class="nx">Age</span> <span class="kt">int</span>
    <span class="nx">Name</span> <span class="nx">strings</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">Men</span><span class="p">)</span> <span class="nf">gender</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Gender</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="nx">Woman</span><span class="p">)</span> <span class="nf">gender</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Gender</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">JudgeFunc</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// may has many code
</span><span class="c1"></span>    <span class="c1">// can&#39;t not get boolean result until running this JudgeFunc
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="nx">Person</span>
    <span class="c1">// so compiler can&#39;t not known clearly about the type info of a
</span><span class="c1"></span>    <span class="nx">a</span> <span class="p">=</span> <span class="nf">JudgeFunc</span><span class="p">()</span> <span class="err">?</span> <span class="nx">Men</span><span class="p">{}</span> <span class="p">:</span> <span class="nx">Woman</span><span class="p">{}</span>

    <span class="kd">var</span> <span class="nx">b</span> <span class="nx">Person</span>
    <span class="c1">// compiler can judge the type info of a 
</span><span class="c1"></span>    <span class="nx">b</span> <span class="p">=</span> <span class="nx">Men</span><span class="p">{}</span> <span class="c1">// or b = Woman{}
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><h3 id="范型">范型 <a href="#%e8%8c%83%e5%9e%8b" class="anchor">🔗</a></h3><p>空interface{} 类型，没有方法集的接口，只需要存类型和类型对应的值即可。</p>
<p>空interface{} = (type, value) ==&gt; (nil, nil) == nil</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">type</span> <span class="nx">eface</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">_type</span> <span class="o">*</span><span class="nx">_type</span>
	<span class="nx">data</span>  <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="p">}</span>

</code></pre></div><h3 id="接口的使用实践">接口的使用实践 <a href="#%e6%8e%a5%e5%8f%a3%e7%9a%84%e4%bd%bf%e7%94%a8%e5%ae%9e%e8%b7%b5" class="anchor">🔗</a></h3><p>golang源码里的较好实现方式是： 使用小的接口，尤其是只包含一个方法的接口；通过小接口的组合来定义大接口。</p>
<p>好处是：使用者可以只依赖于必要功能的最小接口。</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Reader</span>
    <span class="nx">Writer</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">store</span><span class="p">(</span><span class="nx">reader</span> <span class="nx">Reader</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// 入参可以只依赖于必要功能的最小接口， 让函数的返回更广
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">func</span> <span class="nf">store</span><span class="p">(</span><span class="nx">readWriter</span> <span class="nx">ReadWriter</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// 入参依赖了不必要功能的接口，让限制了函数的使用范围为更小
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><h2 id="模糊点">模糊点 <a href="#%e6%a8%a1%e7%b3%8a%e7%82%b9" class="anchor">🔗</a></h2><h3 id="数组与切片">数组与切片 <a href="#%e6%95%b0%e7%bb%84%e4%b8%8e%e5%88%87%e7%89%87" class="anchor">🔗</a></h3><p>数组的初始化 （元素类型， 数组大小）</p>
<p>2种初始化方式，显式的指定数组的大小</p>
<ol>
<li>arr := [3]int{1, 2, 3}</li>
<li>[...]T 声明数组 // arr := [...]int{1, 2, 3}</li>
</ol>
<br/>
<h3 id="函数的接受者">函数的接受者 <a href="#%e5%87%bd%e6%95%b0%e7%9a%84%e6%8e%a5%e5%8f%97%e8%80%85" class="anchor">🔗</a></h3><p>函数接受者为指针类型:</p>
<ol>
<li>函数可以修改接受者的内容</li>
<li>避免方法调用时变量的拷贝，而是指针的拷贝</li>
</ol>
<br/>
<h3 id="golang值拷贝">golang值拷贝 <a href="#golang%e5%80%bc%e6%8b%b7%e8%b4%9d" class="anchor">🔗</a></h3><p>go严格上只有复制拷贝传递</p>
<p>总是创建副本按值传递，只不过这个副本可以是变量的副本，也可以是指针的副本</p>
<br/>
<h3 id="闭包">闭包 <a href="#%e9%97%ad%e5%8c%85" class="anchor">🔗</a></h3><p>闭包=函数+引用环境。</p>
<p>闭包里引用局部变量时，在堆上创建该变量的一个拷贝，并把该变量地址和函数闭包组成一个结构体，并把该结构体传出来作为返回值</p>
<br/>
<h3 id="unsafe包">unsafe包 <a href="#unsafe%e5%8c%85" class="anchor">🔗</a></h3><p>uintptr与unsafe.Pointer（类似void*）</p>
<ol>
<li>T1指针与 T2指针类型之间的转换</li>
<li>修改内存数据， uintptr 常用于与 unsafe.Pointer配合，用于做指针运算</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="c1">//结构体的成员变量在内存存储上是一段连续的内存
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Num</span> <span class="kd">struct</span><span class="p">{</span>
	<span class="nx">i</span> <span class="kt">string</span>
	<span class="nx">j</span> <span class="kt">int64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">Num</span><span class="p">{</span><span class="nx">i</span><span class="p">:</span> <span class="s">&#34;EDDYCJY&#34;</span><span class="p">,</span> <span class="nx">j</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
	<span class="nx">nPointer</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">n</span><span class="p">)</span>
	<span class="c1">// 结构体的初始地址就是第一个成员变量的内存地址
</span><span class="c1"></span>	<span class="nx">niPointer</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">nPointer</span><span class="p">))</span>
	<span class="o">*</span><span class="nx">niPointer</span> <span class="p">=</span> <span class="s">&#34;wuhan&#34;</span>
	<span class="c1">// 基于结构体的成员地址去计算偏移量。就能够得出其他成员变量的内存地址
</span><span class="c1"></span>	<span class="c1">//uintptr 是 Go 的内置类型。返回无符号整数，可存储一个完整的地址。后续常用于指针运算
</span><span class="c1"></span>	<span class="c1">//unsafe.Offsetof：返回成员变量 x 在结构体当中的偏移量。更具体的讲，就是返回结构体初始位置到 x 之间的字节数
</span><span class="c1"></span>	<span class="c1">//uintptr 类型是不能存储在临时变量中的 临时变量是可能被垃圾回收掉的 之后的内存操作有迷茫了
</span><span class="c1"></span>	<span class="nx">njPointer</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">nPointer</span><span class="p">)</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Offsetof</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">j</span><span class="p">)))</span>
	<span class="o">*</span><span class="nx">njPointer</span> <span class="p">=</span> <span class="mi">91</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;n.i: %s, n.j: %d&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">i</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">j</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>指针是对内存区域的地址， 与指针相配合的类型
说明区域有哪些属性，如何去解析。</p>
<br/>
<h3 id="nil">nil <a href="#nil" class="anchor">🔗</a></h3><ul>
<li>what is nil
<ul>
<li>nil is a kind of zero</li>
</ul>
</li>
<li>what is nil in go
<ul>
<li>各种类型的零值</li>
<li>基本类型的零值不为nil
<ul>
<li>bool为false</li>
<li>number为0</li>
<li>string为&quot;&quot;</li>
</ul>
</li>
<li>非基本类型的零值为nil
<ul>
<li>pointer, slice, map, channel, function, interface{} ==&gt; nil</li>
<li>interface{}类型 需要type和value均为nil时，才会为nil</li>
<li>structure{}，因为有结构type存在，type不为nil，所以结构体变量不会是nil</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="反射">反射 <a href="#%e5%8f%8d%e5%b0%84" class="anchor">🔗</a></h3><p>反射 Reflection ，interface对象=（Type, Value）</p>
<p>反射类型 reflect.Type, reflect.Value)</p>
<p>三种反射的基本操作：</p>
<ol>
<li>反射可以将interface类型的变量 转换为 反射对象（reflect.Type reflect.Value）</li>
<li>反射可以将反射对象 还原为interface对象</li>
<li>反射对象可以修改，提前是value值是变量的指针</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">var</span> <span class="nx">x</span> <span class="kt">float</span><span class="p">=</span> <span class="mf">3.1</span> 
<span class="nx">v</span><span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">)</span> <span class="c1">//需要传入x的指针
</span><span class="c1"></span><span class="nx">v</span><span class="p">.</span><span class="nf">Elem</span><span class="p">().</span><span class="nf">SetFloat</span><span class="p">(</span><span class="mf">3.4</span><span class="p">);</span>
</code></pre></div><p>作用：</p>
<ol>
<li>运行时动态调用方法</li>
<li>运行时构造函数进行mock插桩</li>
</ol>
<br/>
<h3 id="内存管理">内存管理 <a href="#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86" class="anchor">🔗</a></h3><ol>
<li>基本想法：局部P上（per cpu）和全局队列想结合的均衡思想。局部分配无需加锁，局部分配无法满足时加锁全局分配</li>
</ol>
<ul>
<li>src/runtime/mheap.go:mspan</li>
<li>内存回收原理
<ul>
<li>三色标记法 （未使用，已使用，带处理）</li>
<li>root对象开始，BFS遍历标记，</li>
</ul>
</li>
<li>逃逸分析（对象是否被函数外面引用 例如闭包； 对象过大也可能在堆中）
<ul>
<li>逃逸分析的目的是决定变量的内存分配地址是在栈还是堆</li>
<li>逃逸分析在编译阶段完成的</li>
<li>传递指针真的比传值高效吗？不一定 由于指针传递会产生逃逸，可能会使用堆，增加GC负担。</li>
<li>go build -gcflags=-m // escapes to heap</li>
</ul>
</li>
</ul>
<br/>
<h2 id="go-汇编">go 汇编 <a href="#go-%e6%b1%87%e7%bc%96" class="anchor">🔗</a></h2><p>Generate x86 Assembly with Go</p>
<p><a href="https://github.com/mmcloughlin/avo">https://github.com/mmcloughlin/avo</a></p>
<ul>
<li>汇编风格分为2类</li>
</ul>
<ol>
<li>intel风格</li>
<li>AT&amp;T风格(左 --&gt; 右) go是plan9， 属于此类</li>
</ol>
<ul>
<li>
<p>助记符    call, add</p>
</li>
<li>
<p>register  ax, sb, pc</p>
</li>
<li>
<p>立即数 $1 , $0x100</p>
</li>
<li>
<p>内存寻址 （R1）</p>
</li>
<li>
<p>plan 9</p>
<ul>
<li><a href="https://lrita.github.io/2017/12/12/golang-asm/#go%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">https://lrita.github.io/2017/12/12/golang-asm/#go%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8</a></li>
<li><a href="https://lrita.github.io/images/posts/go/GoFunctionsInAssembly.pdf">https://lrita.github.io/images/posts/go/GoFunctionsInAssembly.pdf</a></li>
<li><a href="https://github.com/buptbill220/gotls/tree/master/interesting">https://github.com/buptbill220/gotls/tree/master/interesting</a></li>
<li>查看当前cpu架构的指令集合 cat /proc/cpuinfo | grep flags | head -1</li>
<li>指令查询： <a href="http://68k.hax.com/">http://68k.hax.com/</a></li>
<li>命令查询：https://9p.io/magic/man2html/1/8a</li>
<li>plan9 文档： <a href="https://9p.io/sys/doc/">https://9p.io/sys/doc/</a></li>
</ul>
</li>
<li>
<p><a href="https://defuse.ca/online-x86-assembler.htm#disassembly2">https://defuse.ca/online-x86-assembler.htm#disassembly2</a></p>
<ul>
<li>x86 or x64 assembly instructions encoding&lt;==&gt; decoding binary code</li>
<li>It uses GCC and objdump behind the scenes</li>
</ul>
</li>
<li>
<p>goroot/src/syscall --》 建议使用 golang.org/x/sys</p>
</li>
</ul>

    </div>

    
        <div class="tags">
            
                <a href="http://brettkk.github.io/tags/golang">golang</a>
            
        </div>
    
    
    

</section>


    </main>
    
    <footer id="footer">
    

    <p class="copyright">
    
       © Copyright 
       2021 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       
    
    </p>
    <p class="powerby">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

  </body>
</html>
