<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <title>mysql 小结 | brettkk</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="">
<meta name="generator" content="Hugo 0.84.0" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link href="https://cdn.bootcss.com/highlight.js/9.15.10/styles/zenburn.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<link rel="stylesheet" href="http://brettkk.github.io/css/syntax.css" />


<link rel="stylesheet" href="/css/style.css">
<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />








  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	

	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">mysql 小结</h1>

    <div class="tip">
        <span>
          May 5, 2021 11:33
        </span>
        <span class="split">
          ·
        </span>
        <span>
          
            2110 words
          
        </span>
        <span class="split">
          ·
        </span>
        <span>
          5 minute read
        </span>
    </div>

    <div class="content">
      <h2 id="存储">存储 <a href="#%e5%ad%98%e5%82%a8" class="anchor">🔗</a></h2><p>存储引擎-是创建表时设置，存储引擎是表级别的使用</p>
<ul>
<li>
<p>innodb: 只有数据文件即时索引文件，聚集索引，一个表对应一个文件</p>
</li>
<li>
<p>mysiam: 既有数据文件，又有索引文件</p>
</li>
<li>
<p>InnoDB表中数据按行存储 类似网络协议栈，由页头，区头，段头，表头
扇区：磁盘的最小存储单位 512b；</p>
</li>
</ul>
<p>磁盘块：文件系统读写数据的最小单位 4KB；</p>
<p>页：内存的最小存储单位 4KB； 16k，包含多行</p>
<p>一个区由64个页组成，为1M</p>
<p>一个段由多个区组成，构成表空间文件ibd （数据段、索引段、回滚段）</p>
<ul>
<li>mysql innodb存储引擎的文件结构
<ul>
<li>共享表空间文件（ibdata1）</li>
<li>独占表空间文件（ibd）</li>
<li>表结构文件（user.frm， 表名 + .frm组成整个名称），与具体存储引擎无关</li>
<li>日志文件（redo文件等）</li>
</ul>
</li>
</ul>
<p>机械磁盘</p>
<ul>
<li>RAID 0</li>
<li>RAID 1 磁盘镜像，可靠性</li>
<li>RAID 5</li>
<li>RAID 10  RAID 1 后 RAID 0</li>
</ul>
<p>固态硬盘 Sata SSD， PCI-E SSD</p>
<hr>
<h2 id="索引">索引 <a href="#%e7%b4%a2%e5%bc%95" class="anchor">🔗</a></h2><ul>
<li>红黑树 二叉树，深度可能很深</li>
<li>B树 mongodb，允许一个树节点中存多个数据，中间节点存了数据</li>
<li>B+树 innodb
<ul>
<li>只有叶子节点存数据，叶子节点左从到右，从小到达，叶子之间有指针，方便区间查询</li>
</ul>
</li>
</ul>
<h2 id="sql优化">sql优化 <a href="#sql%e4%bc%98%e5%8c%96" class="anchor">🔗</a></h2><ul>
<li>搜索字段上建索引，不在索引字段上使用函数</li>
<li>避免select * ,  这样杜绝去使用覆盖索引
<ul>
<li>在innodb引擎下，select a,b,c 可以走辅助索引找到所有的数据，避免走到聚集索引上，减少一次聚集索引查询过程</li>
<li>减少数据传输量，limit 好习惯</li>
</ul>
</li>
<li>不使用like ‘%xx’, 多用区间操作, 能用 between 就不要用 in</li>
<li>复合索引最左前缀 (不是指SQL语句的where顺序要和复合索引一致)
<ul>
<li>复合索引底层存储也是一颗B+树，只不过排序key=（a,b,c）, 这样是复合索引使用时需要满足最左前缀的原理</li>
</ul>
</li>
<li>避免大事务（避免夹杂rpc）</li>
<li>避免使用子查询， 子查询产生的临时表再扫描无索引可走，会全表扫描</li>
<li>explain 显示select语句的执行计划
<ul>
<li>select_type: simple等</li>
<li>type： 判断查询是否高效，const, ref, range, index,all</li>
<li>extra： using index, using filesort(不能通过索引达到排序), using temporary(使用了临时表)</li>
</ul>
</li>
</ul>
<h2 id="锁">锁 <a href="#%e9%94%81" class="anchor">🔗</a></h2><ul>
<li>mysql 锁
<ul>
<li>mysql锁类型，锁机制 （InnoDB 检索数据走索引是行锁，不走索引是表锁）
<ul>
<li>行级锁
<ul>
<li>Record Lockx 对索引项加锁，锁定一条记录</li>
<li>Gap Lockx 锁定一个范围，不包含记录本身</li>
<li>Next-Key Lock = gap + record lock, 锁定一个范围 并锁定记录本身
<ul>
<li>查询的索引包含唯一属性时，next-key lock 降级为record lock</li>
</ul>
</li>
</ul>
</li>
<li>表级锁</li>
</ul>
</li>
</ul>
</li>
<li>死锁的必要条件
<ul>
<li>互斥</li>
<li>请求并保留</li>
<li>不剥夺</li>
<li>循环等待</li>
</ul>
</li>
<li>死锁的注意事项：
<ul>
<li>InnoDB的索引的修改会锁定更多的行</li>
<li>InnoDB加锁是边查询边加锁，逐行获得锁</li>
<li>InnoDB表的并发过多，会达到锁的最大深度，或者锁的最大</li>
<li>锁的升级也会导致死锁，建议事务开始就获得所有资源</li>
</ul>
</li>
</ul>
<h2 id="事务原理">事务原理 <a href="#%e4%ba%8b%e5%8a%a1%e5%8e%9f%e7%90%86" class="anchor">🔗</a></h2><ul>
<li>mysql transaction （ACID 锁保证隔离性， relog 保证原子性和持久性， undo保证一致性）
<ul>
<li>隔离级别 可在终端进行模拟
<ul>
<li>read uncommited （tranx will read dity data）
<ul>
<li>读脏数据</li>
</ul>
</li>
<li>read committed (no repeatable read)
<ul>
<li>不可重复读（事务中两次读的结果不一致）</li>
<li>事务1等读到事务2的commit， 从数据库对事务ACID角度上讲，违背了隔离性</li>
</ul>
</li>
<li>repeatable read (default mode)
<ul>
<li>事务在运行时看到相同的数据，可重复读</li>
<li>存在幻读（innodb的间隙锁解决）</li>
</ul>
</li>
<li>seriablizable</li>
</ul>
</li>
<li>mvcc
<ul>
<li>Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</li>
<li>对某条记录的第一次快照读会创建一个快照及Read View，之后的快照读获取的都是同一个Read View， RR</li>
<li>每次快照读都会新生成一个快照和Read View, 在RC级别下的事务中可以看到别的事务提交的更新</li>
</ul>
</li>
</ul>
</li>
<li>innodb重要的日志，undo logs, redo logs
<ul>
<li>undo logs: 记录某数据被修改前的值，可以用来在事务失败时进行rollback，保证一致性
<ul>
<li>逻辑日志，随机写，每行记录修改， 采用段的方式</li>
<li>帮助事务回滚以及MVCC功能</li>
</ul>
</li>
<li>redo logs: 保证事务的原子性和持久性
<ul>
<li>物理日志，顺序写，512字节，记录的是页的物理修改操作</li>
<li>确保redo log写入磁盘，事务提交前需要fsync操作。 因此磁盘的性能决定了事务提交的性能。</li>
</ul>
</li>
</ul>
</li>
<li>undo+redo log
<ul>
<li>为保证事务的持久性，事务提交前先写redo log持久化（WAL）</li>
<li>数据不需要在事务提交前写入磁盘，而是在内存的缓存中</li>
<li>redo log保证事务的持久性， undo log保证事务的原子性</li>
</ul>
</li>
</ul>
<hr>
<h2 id="数据同步">数据同步 <a href="#%e6%95%b0%e6%8d%ae%e5%90%8c%e6%ad%a5" class="anchor">🔗</a></h2><ul>
<li>Master-Slave 原理 （Binlog, Relay log）
<ul>
<li>异步复制
<ul>
<li>主库
<ul>
<li>当从库连接式，binlog dump thread发送binlog event,并持有event的lock</li>
<li>IO thread 读完后释放lock</li>
</ul>
</li>
<li>从库
<ul>
<li>IO thread读binlog event，生成relay log</li>
<li>SQL thread 读relay log，执行</li>
</ul>
</li>
</ul>
</li>
<li>Binlog, Relay log
<ul>
<li>SQL(增删改查，DDL)语句按 提交顺序 生成的日志，用于数据回滚，异步复制</li>
<li>Relay log通过异步复制Master中的binlog，生成slave的执行日志</li>
<li>Binlog的3种存储格式：binlog_format(row, statement, mixed)
<ul>
<li>statement格式： 每一条会修改数据的sql都会记录在binlog中</li>
<li>row： 不记录sql语句上下文相关信息，仅保存哪条记录被修改</li>
<li>mixed： 混合	（Binlog记录数据库发生的变化,用于replication）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="使用">使用 <a href="#%e4%bd%bf%e7%94%a8" class="anchor">🔗</a></h2><p>数据库使用自增主键作为唯一key时可能的问题： 分库分表时，会出现主键重复。</p>
<ul>
<li>字符类 (char,varchar,text,blob)</li>
<li>varchar(50)表示最大存放50个字符, char</li>
<li>int(10)表示最大显示宽度为10,存储还是占4字节</li>
<li>时间日期类
<ul>
<li>date, '1000-01-01' to '9999-12-31'</li>
<li>datetime, '1000-01-01 00:00:00' t0 '9999-12-31 00:00:00',范围广</li>
<li>timestamp, '1970-01-01 00:00:01' UTC to '2038-01-19 03:14:07' UTC</li>
</ul>
</li>
</ul>

    </div>

    
        <div class="tags">
            
                <a href="http://brettkk.github.io/tags/%E5%AD%98%E5%82%A8">存储</a>
            
        </div>
    
    
    

</section>


    </main>
    
    <footer id="footer">
    

    <p class="copyright">
    
       © Copyright 
       2021 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       
    
    </p>
    <p class="powerby">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

  </body>
</html>
