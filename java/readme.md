缓存穿透解决方案
+ 缓存空值，一次
+ 布隆过滤器

缓存失效
+ 使用缓存集群，保证高可用
+ Hystrix工具， 熔断、降级、限流
+ 互斥锁，让其他请求等待缓存数据更新


类加载主要做三件事：
+ 通过类名从class文件中获取字节流
+ 将字节流存储在方法区上的运行时数据结构
+ 在堆上生成Class对象，作为这个类在方法区上的访问入口


优化写入速度Kafak采用了两个技术
+ 顺序写入（顺序写磁盘效率比随机写内存高）
+ MMFile

---
获取消息 = topic + patition + offset

---

传送保证
+ at most once 最多一次， 消息会丢失，不会重复传输
+ at least once 最少一次， 消息不丢失，会重复传输 （kafka默认）
+ exactly once 有且仅有一次，（与外部存储系统协作）
  + 生产者发消息时附带pid+messageid， broker检查messageid是否比我的messageid大于1， 是则接受；不是拒接
  + 消费者更新数据和更新offet需要事务支持，一起成功或者一起失败，保证正好消费一次



[reference](https://legacy.gitbook.com/book/soulmachine/system-design/details)
---
### 设计一个分布式ID生成器

需求： 唯一，按照时间粗略有序，尽可能短

1 uuid, mongoDB的12字节ObjectId的做法： 4字节timestamp，3字节机器id，2字节进程号，3字节计数器

2 单台mysql可以生成自增id，做法：8台mysql服务器，第一台初始id为1，自增8，第二台为2，以此类推，缺点：id不是严格递增的

3 twitter snowflake算法

---
### 设计一个短网址服务(TinyURL)

场景：twitter分享url地址长度有限制

需求：尽可能的短

网页总量大约45亿，7个字符够用，一个字符62种可能值（数字，字母，大小写， 62^7大于45亿）

发号器

一个长地址+用户名+user agent信息 -》生成短地址（所以一个长地址对应多个短地址）

301（永久重定向），302（短地址用这个，零时）的区别，以及浏览器缓存机制的理解

---
### 实现一个定时任务调度器，有很多任务，每个任务都有一个时间戳，任务会在该时间点开始执行

PriorityQueue: 底层数据结构为数组，堆排序

PriorityBlockingQueue

1 DelayQueue(PriorityQueue+Lock) 计算时间差,让消费者等待该时间差集成进了队列

2 时间轮

---
### 给定一个公共API，限制每个用户每秒只能调用1000次

B/ratelimit

---
### 请设计一个线程安全的HashMap

jdk8以上的concurrenthashmap: 小粒度锁，CAS，链表长度大于8时采用红黑树

解决hash冲突的方法：

链地址法：将哈希值相同的元素存放到同一个链表上

---
### 实时输出最近一个小时内访问频率最高的10个IP
+ 实时输出
+ 从当前时间向前数的1个小时
+ QPS可能会达到10W/s

----
### 设计一个负载均衡器

硬件负载均衡器： F5，深信服
软件负载均衡： Nginx

---
### 设计一个Key-Value存储引擎

参照RocksDB，levelDB（基于 LSM(Log-Structured-Merge Tree) 的典型实现）

观点：硬盘的顺序读写速度很快（与内存读写速度的比较需要实验验证）

lsm_tree对索引变更进行延迟及批量处理，通过一种类似于归并排序的方式高效地将更新迁到磁盘

update和delete操作转为顺序写

levelDB主要结构
+ 内存： memTable, immutable memetatble
+ 外存：current文件，manifest文件，log文件，SSTable文件

读过程
+ 随机读性能达到6万条记录每秒
+ memTable -> SSTable文件。内存-》磁盘

写过程
+ 随机写性能达到40万条记录每秒
+ 一次顺序写文件+内存skiplist插入，速度快。更新，删除，插入都相当于插入操作。
---
### 大数据方向

数据流采样： 无限的整数数据流，如何从中随机地抽取k个整数出来？

蓄水池算法：前k个整数到达时，全部保留，即被选中的概率是 100%，
第i个整数到达时，以k/i的概率替换k个数中的某一个，以的1-k/i概率丢弃，保留k个数不变

---
### 寻找数据流中出现最频繁的k个元素

1 数据分片，hashmap+ min heap

---
### 给定一个无限的数据流和一个有限集合，如何判断数据流中的元素是否在这个集合中

Bloom Filter = bit map + k hash func

-----

### 设计一个消息队列，实现消息的发布与订阅

redis作消息队列

kafka

rockMq

----

### 分布式锁

+ zookeeper（永久节点下，创建临时顺序节点）
+ redis
+ memcached

-----

### 分布式缓存

+ redis集群如何与mysql集群同步

redis和memcached的区别。
+ redis支持多种数据结构
  + redis的数据结构,zset的底层原理,跳跃表

redis是单线程的么，所有的工作都是单线程么。
redis如何存储一个String的。
redis的部署方式，主从，集群。
redis的哨兵模式，一个key值如何在redis集群中找到存储在哪里。
redis持久化策略。

+ memcached集群
------

### 分布式事务处理方案

状态： 成功、失败和超时（超时有可能成功，或者失败）

2PC：每个节点只知道自己成功或者失败，所以需要引入协调者， 第一轮准备阶段；第二轮提交或者回滚阶段

TCC机制
+ Try：预留业务资源
+ Confirm：确认执行业务操作
+ Cancel：取消执行业务操作


利用mq实现
+ 生产者修改A库，发送消息到MQ并存入本地消息表， 消费者接受到消息修改B库通知A成功，A消除消息表记录，修改失败通知A回滚，保证最终一致性
---

### 设计一个秒杀系统

+ 前台静态资源走CDN加速
+ 限流， 同一时间段内同一用户禁止发送大量请求
+ 任务异步化， 下单，短信通知等业务异步处理，避免同步阻塞
+ 合理的缓存，不需要实时更新的热点数据避免查询数据库
+ 其他业务降级